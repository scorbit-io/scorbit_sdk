# ECDSA signature

We are using ECC keys with a named curve `prime256v1` (aka `secp256r1` aka `NIST256p` aka `P-256`). The ECDSA can sign only 32 byte fixed length source. Therefore, for arbitrary message we first take SHA-256 digest and then sign that digest by ECDSA.

The raw private key is a 32 bytes length array, and the raw public key is a 64 bytes length array. The raw signature is a 64 bytes length array.

## Key pair generation

Generate private key:

```bash
$ openssl ecparam -name prime256v1 -genkey -noout -out private.pem
```

content of the example private key:

```bash
$ cat private.pem 
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIBvr3BbIO7OCdhWeKRA3c8rji14DrttgWM4/8I+vkVmkoAoGCCqGSM49
AwEHoUQDQgAEQtdLzHvOJSCgSeXlBo9LqxwDK/ZaUiQcNXo9ERM4PlrtLR14ncE4
yZtZt4JcySN7g+mrCuGiQPU8HAYgN0Hdsg==
-----END EC PRIVATE KEY-----
```

Get raw keys arrays:

```bash
$ openssl ec -in private.pem -text --noout
read EC key
Private-Key: (256 bit)
priv:
    1b:eb:dc:16:c8:3b:b3:82:76:15:9e:29:10:37:73:
    ca:e3:8b:5e:03:ae:db:60:58:ce:3f:f0:8f:af:91:
    59:a4
pub:
    04:42:d7:4b:cc:7b:ce:25:20:a0:49:e5:e5:06:8f:
    4b:ab:1c:03:2b:f6:5a:52:24:1c:35:7a:3d:11:13:
    38:3e:5a:ed:2d:1d:78:9d:c1:38:c9:9b:59:b7:82:
    5c:c9:23:7b:83:e9:ab:0a:e1:a2:40:f5:3c:1c:06:
    20:37:41:dd:b2
ASN1 OID: prime256v1
NIST CURVE: P-256
```

The `priv` section is 32 bytes array which will be securely (obfuscated) stored in the machine.

The `pub` section shows as 65 bytes, first byte `04` is a service byte (which we will omit) and followed by 64 bytes of public key. That will be used in API as:

```python
pub_key = bytes.fromhex('42d74bcc7bce2520a049e5e5068f4bab1c032bf65a52241c357a3d1113383e5aed2d1d789dc138c99b59b7825cc9237b83e9ab0ae1a240f53c1c06203741ddb2')
```

## Creating signature

Message is an arbitrary length byte array. To create signature of message:

1. Calculate SHA-256 digest of the message and get it to 32 bytes array (`digest`)
2. Using private key create signature of the `digest` which results to 64 byte of `signature` array

## Example: creating signature using openssl command line tool

In this example we use openssl tool to sign the message and get it's 64 bytes signature:

1. Create a test message file and cut trailing `\n` character:

```
$ echo "test message" | tr -d '\n' > message.txt
```

1. Create a signature of message.txt using openssl. This is designed to create signature using a random seed, so every time the signature for the same message will be different (unless using deterministic signing):

```
$ openssl dgst -sha256 -sign private.pem -out message.sign  message.txt
```

This signature is in DER format, so, depending on signature it could be 71 or 72 bytes long while raw signature is 64 bytes long.

1. Dump signature to HEX:

```
$ cat message.sign | hexdump -v -e '/1 "%02X"' ; echo
3045022100C9EE725C00638E05C10BE3CB8A478B384FB2CB08673FCB5A584CC74BA4ED667802205B05BC7181A343F875631150C0FD76666DA4B3302E85752C89087A33CB831DC6
```

Same signature in a raw format (64 bytes) is:

```
c9ee725c00638e05c10be3cb8a478b384fb2cb08673fcb5a584cc74ba4ed66785b05bc7181a343f875631150c0fd76666da4b3302e85752c89087a33cb831dc6
```

We will use both formats in the python verification example.

## Example: python verification using `ecdsa` module

This is the `test_ecdsa.py` file to verify given test message and public key:

```python
from ecdsa import VerifyingKey, NIST256p, BadSignatureError
from ecdsa.util import sigdecode_der, sigdecode_string
import hashlib

# pub_key is constant and will never change
pub_key = bytes.fromhex('42d74bcc7bce2520a049e5e5068f4bab1c032bf65a52241c357a3d1113383e5aed2d1d789dc138c99b59b7825cc9237b83e9ab0ae1a240f53c1c06203741ddb2')
vk = VerifyingKey.from_string(pub_key, curve=NIST256p, hashfunc=hashlib.sha256)
# vk is constant and we can pre-compute it's value to speedup the verifying process
vk.precompute()

def verify(sign, msg):
    try:
        vk.verify(sign, msg, sigdecode = sigdecode_string if len(sign) == 64 else sigdecode_der)
        print("signature verified ok")
    except BadSignatureError:
        print("bad signature")

msg = b'test message'
bad_msg = b'altered message'
sign_raw = bytes.fromhex('C9EE725C00638E05C10BE3CB8A478B384FB2CB08673FCB5A584CC74BA4ED66785B05BC7181A343F875631150C0FD76666DA4B3302E85752C89087A33CB831DC6')
sign_der = bytes.fromhex('3045022100C9EE725C00638E05C10BE3CB8A478B384FB2CB08673FCB5A584CC74BA4ED667802205B05BC7181A343F875631150C0FD76666DA4B3302E85752C89087A33CB831DC6')
sign_bad = bytes.fromhex("ffffffB67F72F5390A9D227C98EB77400B1E3C99C92330D834239EA6B9185F3066C59F6E8F00901A6BB9BBE639A9FFA5F985F52702066A97157ADEBEED7E5677")

verify(sign_raw, msg)
verify(sign_der, msg)
verify(sign_der, bad_msg)
verify(sign_bad, msg)
```

Output:

```
$ python test_ecdsa.py 
signature verified ok
signature verified ok
bad signature
bad signature
```
