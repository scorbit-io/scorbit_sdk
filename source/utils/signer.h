/****************************************************************************
 *
 * @author Dilshod Mukhtarov <dilshodm(at)gmail.com>
 * Sep 2024
 *
 ****************************************************************************/

#pragma once

#include <scorbit_sdk/net_types_c.h>
#include <openssl/sha.h>
#include <openssl/evp.h>
#include <openssl/ec.h>
#include <openssl/ecdsa.h>
#include <cstdint>
#include <cstddef>
#include <memory>
#include <vector>

// To supresss OpenSSL 1.0.x API's deprecation warnings
#if defined(__GNUC__)
#    pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__clang__)
#    pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

namespace scorbit {
namespace detail {

// typedef enum {
//     SIGN_OK = 0,
//     SIGN_ERR_OPENSSL_INIT,      // Failed to initialize OpenSSL
//     SIGN_ERR_CREATE_EC,         // Failed to create EC_KEY
//     SIGN_ERR_CREATE_BIGNUM,     // Failed to convert key to BIGNUM
//     SIGN_ERR_SET_PRIV_KEY,      // Failed to set private key
//     SIGN_ERR_CREATE_POINT,      // Failed to create EC_POINT
//     SIGN_ERR_CALC_PUB_KEY,      // Failed to calculate public key
//     SIGN_ERR_SET_PUB_KEY,       // Failed to set public key
//     SIGN_ERR_INVALID_KEY,       // Invalid key
//     SIGN_ERR_KEY_CANNOT_SIGN,   // Key cannot sign
//     SIGN_ERR_SIGN_FAILURE,      // Failed to sign the digest
//     SIGN_ERR_INVALID_SIGNATURE, // Invalid signature generated
// } SignErrorCode;

/**
 * @brief scorbit_sign used to sign given digest with the given private key.
 *
 * @param[out] signature - generated signature in DER format, it has to be pre-allocated buffer with
 *      at least SB_SIGNATURE_MAX_LENGTH (72) bytes.
 * @param[out] signature_len - actual length of the signature, not more than SB_SIGNATURE_MAX_LENGTH
 *      (72) bytes.
 * @param[in] digest - digest to sign (32 bytes), it's a SHA-256 hash, can be generated by
 *      @ref scorbit_digest.
 * @param[in] key - private key in binary format (32 bytes).
 *
 * @return error code or SIGN_OK if successful.
 */
// extern SignErrorCode scorbit_sign(uint8_t signature[SB_SIGNATURE_MAX_LENGTH], size_t
// *signature_len,
//                                   const uint8_t digest[SB_DIGEST_LENGTH],
//                                   const uint8_t key[SB_KEY_LENGTH]);

enum class SignErrorCode {
    Ok = 0,
    OpenSSLInitFailure,
    CreateECKeyFailure,
    CreateBIGNUMFailure,
    SetPrivateKeyFailure,
    CreateECPointFailure,
    CalculatePublicKeyFailure,
    SetPublicKeyFailure,
    InvalidKey,
    KeyCannotSign,
    SignFailure,
    InvalidSignature
};

class Signer
{
public:
    static SignErrorCode sign(std::vector<uint8_t> &signature,
                              const std::array<uint8_t, SB_DIGEST_LENGTH> &digest,
                              const std::vector<uint8_t> &key)
    {
        EC_KEY_ptr ecKey(EC_KEY_new_by_curve_name(NID_X9_62_prime256v1), EC_KEY_free);
        if (!ecKey)
            return SignErrorCode::CreateECKeyFailure;

        BIGNUM_ptr privKeyBn(BN_bin2bn(key.data(), key.size(), nullptr), BN_free);
        if (!privKeyBn)
            return SignErrorCode::CreateBIGNUMFailure;

        if (EC_KEY_set_private_key(ecKey.get(), privKeyBn.get()) != 1)
            return SignErrorCode::SetPrivateKeyFailure;

        EC_POINT_ptr ecPoint(EC_POINT_new(EC_KEY_get0_group(ecKey.get())), EC_POINT_free);
        if (!ecPoint)
            return SignErrorCode::CreateECPointFailure;

        if (EC_POINT_mul(EC_KEY_get0_group(ecKey.get()), ecPoint.get(), privKeyBn.get(), nullptr,
                         nullptr, nullptr)
            != 1)
            return SignErrorCode::CalculatePublicKeyFailure;

        if (EC_KEY_set_public_key(ecKey.get(), ecPoint.get()) != 1)
            return SignErrorCode::SetPublicKeyFailure;

        if (EC_KEY_check_key(ecKey.get()) != 1)
            return SignErrorCode::InvalidKey;

        if (EC_KEY_can_sign(ecKey.get()) != 1)
            return SignErrorCode::KeyCannotSign;

        ECDSA_SIG_ptr sig(ECDSA_do_sign(digest.data(), digest.size(), ecKey.get()), ECDSA_SIG_free);
        if (!sig)
            return SignErrorCode::SignFailure;

        int len = i2d_ECDSA_SIG(sig.get(), nullptr);
        if (len <= 0)
            return SignErrorCode::InvalidSignature;

        signature.resize(len);
        uint8_t *sigData = signature.data();
        i2d_ECDSA_SIG(sig.get(), &sigData);

        return SignErrorCode::Ok;
    }

private:
    using EC_KEY_ptr = std::unique_ptr<EC_KEY, decltype(&EC_KEY_free)>;
    using BIGNUM_ptr = std::unique_ptr<BIGNUM, decltype(&BN_free)>;
    using EC_POINT_ptr = std::unique_ptr<EC_POINT, decltype(&EC_POINT_free)>;
    using ECDSA_SIG_ptr = std::unique_ptr<ECDSA_SIG, decltype(&ECDSA_SIG_free)>;
};

} // namespace detail
} // namespace scorbit
