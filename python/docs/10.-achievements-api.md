# Achievements-API

### Achievements API

The achievements API serves the purpose of both connecting the machines and Scorbitrons to the achievements in the user profiles, as well as serving queries for visualizations of those achievements. It will be served initially over a REST API with individual connections, but is also being made available via a websocket implementation in the future as is currently the case with the /entry scores endpoint.

### Philosophy

Scorbit's Achievement Engine is driven by two categories of actions:

1. Real-time actions that are generally triggered by game code
2. Post-game actions that are generally triggered by any platform data, including other achievements, venues, time of day, or non-session specific externalities

Achievements and their associated logic are _**stored**_ in the Scorbit platform. In most cases, they are _**processed**_ by the game or Scorbitron hardware. This is because often achievements are presented to the player on the game itself, and in some situations may effect gameplay. Also, the latencies on a machine are predictable, and waiting for the API could introduce problems of sequencing. Finally, spreading the compute across a naturally distributed set of CPUs is very scalable.

To create rules for achievements, they can either be edited via the Scorbit admin panels, imported by CSV file, or created/edited in the **Achievement Builder** (or Builder for short). The builder has not been released yet.

### Synchronizing States Between Machines and the API

As a result of the dual processing capability, achievements are sometimes triggered by events that happen during a session. Other times they are driven by events outside of a session. As a result, Scorbit's platform is aware of both of these states, and it requires that the machine or game code processing be aware of the user's previous achievements or outside achievements if they are relevant.

When a machine is using the Scorbit API directly, it is assumed that the _**game code**_ will be pulling and tracking this information, and updating the API as those counts/variables change, **in real-time**.

When a machine (generally a vintage machine) is using a Scorbitron, we assume that the Scorbitron code is pulling and tracking this information, and updating the API.

#### Two Endpoints: `api/achievement` and `api/user_achievement`

Achievements is broken into two endpoints to serve these purposes, achievements and user\_achievements. The **achievement** endpoint is primarily used by the Scorbitron to get a master set of achievements to track during a game session. The **user\_achievement** endpoint is used by both a native API connection or the Scorbitron at the moment a user claims a player slot, as before that point, there is no way to know who the user is and if the user has achieved anything.

The achievement endpoint should be hit on initial connection to the API. If the achievement model changes, a refresh message will be sent to reload the master set.&#x20;

The user\_achievement endpoint should be hit at the moment a user claims a slot. It can take multiple userIDs as arguments in the case where multiple players all claim at the same time, but can be hit as often as required.

The flow of interacting with the achievement endpoints is as follows:

1. Venuemachine authenticates with API and gets stoken
2. Venuemachine queries /api/achievement set of achievements from API for associated machineID
3. Game logic or Scorbitron sets measures and metrics according to loaded logic
4. During active session, player _**claims**_ a player slot
5. Entry/scores endpoint responds immediately with userId information
6. Venuemachine queries /api/user\_achievement for all currently unlocked or partially unlocked achievements for that userId, delivered in a list of user\_achievements.
7. Venuemachine measures game play according to achievements logic. If achievement count increments the first time, /api/achievement/unlock is sent a POST to create a new user\_achievement for that userId with the initial count. Note that **unlock** doesn't mean **achieved.** It means that the user has begun the process of unlocking the achievement, measuring whatever count is relevant.
8. For each unlocked or partially unlocked achievement, api/user\_achievement is updated with current information in the form of a list of updates with new counts. This can be done at any frequency, designed to handle it as a batch of updates.
9. The user\_achievement endpoint responds with any changes from the API side of the equation, with achieved=true if something changes outside of the session logic. Otherwise, the venuemachine continues to update all unlocked or partially unlocked achievements.
10. If the venuemachine detects a change from achieved=false to achieved=true, whether by it's own measuring logic or a change from the API, the user is typically alerted in game with an overlay. As soon as the API knows of a transition from false to true, it also notifies the user in the form of a push. notification.

### Achievement Model and Importing

A game achievement's complexity is completely driven by the author and the capabilities of the game code. The following table breaks down the different features in the current Achievement schema. The "Model Field" refers to the name of the field as it exists in the Scorbit database. "Description" is a simple definition of the field's purpose. "CSV Header" is the header in the first row of a csv file used to import achievements from a file. Finally, "notes" are further information to help understand the context of the field. If you would like any field below added to the import tool, let us know.

<table data-full-width="true"><thead><tr><th width="142">Model Field</th><th width="188">Description</th><th width="145">CSV Header</th><th width="120">Type</th><th>Notes</th></tr></thead><tbody><tr><td>draft</td><td>Is this achievement visible to players yet. If an achievement is set to draft=true, only the owner or owners of the achievement object permissions will see the achievement in the app or other tools.</td><td>N/A</td><td>boolean</td><td>This is very useful for game launches or times when you want to work/test achievements without players seeing them in feeds or machine screens. All achievements default to draft=true and can be published (draft=false) via the admin GUI.</td></tr><tr><td>group_id</td><td>If multiple achievements count the same value (i.e. 10 spins, 100 spins, 1000 spins), they should share a group_id. When creating a CSV file, these should start at group 0 and increment by one for each unique group. </td><td>groupid</td><td>integer</td><td>At time of import, the group IDs will begin with the next available groupID and increment automatically at time of import. If you re-import, only identical keys will get overwritten, so be aware of any orphaned keys when you choose to renumber.</td></tr><tr><td>id</td><td>Unique ID for a master achievement. When creating a CSV file, these should start at 0 and increment by one for each unique achievement, regardless of group.</td><td>achievementid</td><td>integer</td><td>At the time of import, these IDs will be automatically generated beginning with achievementid 0 in the CSV file.</td></tr><tr><td>key</td><td>Unique code identifying the achievement, [manufacturer prefix]-[machine abbreviation]-[group_id]-[id]</td><td>N/A</td><td>string<br>(32 chars)<br>'DP-TBL-0-0'</td><td>Auto-generated by combining manufacturer, machine abbreviation, group id and unique id.</td></tr><tr><td>name</td><td>Name of the achievement. When obscured = true, this name will be hidden in the app.</td><td>name</td><td>string<br>(255 chars)</td><td></td></tr><tr><td>description</td><td>Description of the achievement. This should inform the player how to unlock the achievement.</td><td>description</td><td>string<br>(255 chars)</td><td></td></tr><tr><td>machines</td><td>list of machineIDs, machine names relevant to the achievement (optional). When an achievement refers to specific group of machineIDs (i.e., a Pro, LE, CE of a machine have unique IDs but all get the same achievements). If this refers to a single machine, it should be a list of one.</td><td>N/A</td><td>list of objects</td><td> Import tool requires setting this list in the admin UI</td></tr><tr><td>scope</td><td><p>'specific' or ' global'</p><p>Specific is an achievement focused on being earned through game sessions. Global is an achievement which is not specific to a machine. All game-earned achievements are specific.</p></td><td>N/A</td><td>string:<br>'specific'<br>'global'</td><td>All achievements imported are specific at this time</td></tr><tr><td>permanence</td><td>permanent/trophy, trophy achievements can only be held by one player</td><td>N/A</td><td>string:<br>'permanent'<br>'trophy'</td><td> All achievements imported are permanent at this time, but can be adjusted though admin GUI.</td></tr><tr><td>visible</td><td><p>'invisible' or 'visible'</p><p>Invisible achievements aren't seen by users and are ingredients to other achievements</p></td><td>visible</td><td>string:<br>'visible'<br>'invisible'</td><td>Invisible achievements are meant to be achievements used as ingredients for other achievements.</td></tr><tr><td>type</td><td>counter/boolean, most achievements have a counter</td><td>type</td><td>string:<br>'counter'<br>'boolean'</td><td>Boolean is deprecated and all achievements should be set to counter. A counter with a count of 1 is the same as a boolean.</td></tr><tr><td>input_time</td><td>limited/unlimited, is the achievement limited to being achieved during a single game session, or can the achievement count increase beyond a single session.</td><td>input_type</td><td>string:<br>'limited'<br>'unlimited'</td><td>Limited achievements are meant to be achieved during a single session, like can you get multiball four times in a single game. Unlimited achievements are meant to be measured and stored between games, like how many times over your lifetime you have achieved multiball. <em><strong>Limited achievement counts reset to 0 at the start of each session.</strong></em></td></tr><tr><td>image</td><td>URI of achievement badge image</td><td>image</td><td>string (URI): 'achievement_images/Achievement__[name].png'</td><td></td></tr><tr><td>count</td><td>All achievements are measures of something, even if it's only counting one. This number, when reached, will be used to determine if an achievement is unlocked.</td><td>count</td><td>integer</td><td></td></tr><tr><td>processing</td><td>immediate/post-game, when the achievement is processed</td><td>N/A</td><td>string:<br>'Immediate'<br>'Post Game'</td><td>Currently all achievements are Immediate. Reserved for future use.</td></tr><tr><td>trigger</td><td>game/mode/score/subachievement, what source triggers the achievement change.<br>Game refers to game code determining what increments count. <br>Mode refers to a active mode triggering an increment of the count.<br>Score refers to a specific score value incrementing the count.<br>Subachievement refers to another achievement being the trigger of the count.</td><td>trigger</td><td>string:<br>'game'<br>'mode'<br>'score'<br>'subachievement'</td><td>This field is generally used by a Scorbitron to understand from the achievement author what to use as a basis of an achievement. Game is the most common for direct-connected machines where achievements are coded into the game. In most cases, where game code is not open to change, the mode or scores are values that can be observed from outside the game to trigger actions.</td></tr><tr><td>notify_when_achieved</td><td>Unlocked achievements notify the player, but not the player's followers, by default. For major achievements, if this is set to true, followers of the player will get notified.</td><td>notify_when_achieved</td><td>boolean</td><td>Easier to achieve achievements would spam followers pretty quickly, so this should be used only for extremely unusual or difficult achievements, or trophy achievements.</td></tr><tr><td>mode_type</td><td>When triggering based on mode, you can choose to base it on mode starting, mode completing, or mode stacking.</td><td>mode_type</td><td>string:<br>'start'<br>'complete'<br>'stack'</td><td>This is only necessary for mode triggers, so primarily for Scorbitrons, not direct-connected machines.</td></tr><tr><td>mode_name</td><td>the Scorbit platform name for the mode in the game template</td><td>mode_name</td><td>string</td><td>The name of the mode used in the DMD template or sent to the API in session logs.</td></tr><tr><td>mode_name_2</td><td>When mode_type is stack, indicate a second mode name</td><td>mode_name_2</td><td>string</td><td></td></tr><tr><td>mode_name_3</td><td>When mode_type is stack, indicate a third mode name (when necessary)</td><td>mode_name_3</td><td>string</td><td></td></tr><tr><td>duration</td><td>Used when measuring the length of time a mode, ball or session needs to be active to unlocking an achievement</td><td>N/A</td><td>integer (ms)</td><td>If the achievement is of trigger type of "mode," the assumption is this is associated with measuring mode duration. The same is true with different trigger types.</td></tr><tr><td>ball_count</td><td>Maximum total number of balls played in a session prior to unlocking an achievement</td><td>N/A</td><td>integer</td><td>If the logic wants to grant an unlocked achievement for measuring something completed prior to a set number of balls being played in a single session, this would be used. For example, get to wizard mode in ball 1.</td></tr><tr><td>target_score</td><td>integer of a target score used in calculating achievement</td><td>target_score</td><td>integer</td><td>When the achievement is measuring a score, indicate here the number that will be used.</td></tr><tr><td>comparison</td><td>Operand for use with a target_score</td><td>comparison</td><td>string:<br>'>'<br>'&#x3C;'<br>'='</td><td>Any achievement which is comparing two things can use this field to determind the boolean logic comparison.</td></tr><tr><td>primary_achievement</td><td>pointer to another parent achievement for which this is an ingredient</td><td>N/A</td><td>pointer to ForeignKeyID of achievement</td><td></td></tr><tr><td>obscure</td><td>true/false, is this achievement obscured from detail until achieved</td><td>obscure</td><td>boolean</td><td>Obscured achievements still display in visuals. However, their names and achievement images are hidden until they are unlocked.</td></tr><tr><td>obscure_image</td><td>URI of image to use when displaying obscured achievements prior to unlocking</td><td>obscure_image</td><td>string (URI): <code>'achievement_images/Achievement__[name].png'</code></td><td></td></tr><tr><td>venue</td><td>venueId of a venue used to determine eligibility of an achievement</td><td>venue</td><td>ForeignKey, referes to venue object</td><td>Typically used when promoting an event or location, such as "Unlocked Expo 2023."</td></tr><tr><td>frame</td><td>URI of zip file containing any overlay frames used by the game when an achievement is fully unlocked</td><td>N/A</td><td>string</td><td>For DMD achievements, this zip file is updated via the admin GUI, builder application, or Pinball Browser client editing tool.</td></tr><tr><td>frame_version</td><td>Version number of the current zip file. Used by Scorbitron to determine if a new zip file needs to be downloaded.</td><td>N/A</td><td>integer</td><td></td></tr></tbody></table>

### Example Import Tool CSV File Format

The following is an example csv file used by the import tool:

```
groupid,achievementid,name,description,count,input_time,visible,type,notify_when_achieved,obscure,obscure_image,image,trigger,target_score,venue,mode_name,mode_name_2,mode_name_3,mode_type,comparison
0,0,HAUNTED TRAILS,EARN HAUNTED FOREST SKILL SHOT 1 TIME,1,unlimited,TRUE,counter,FALSE,FALSE,achievement_images/Achievement___obscured.png,achievement_images/Achievement__WOZ_Blue_3_Star.png,game,,,,,,,
0,1,HAUNTED ROADS,EARN HAUNTED FOREST SKILL SHOT 25 TIMES,25,unlimited,TRUE,counter,FALSE,TRUE,achievement_images/Achievement___obscured.png,achievement_images/Achievement__WOZ_Blue_3_Star.png,game,,,,,,,
0,2,HAUNTED HIGHWAYS,EARN HAUNTED FOREST SKILL SHOT 50 TIMES,50,unlimited,TRUE,counter,FALSE,TRUE,achievement_images/Achievement___obscured.png,achievement_images/Achievement__WOZ_Blue_3_Star.png,game,,,,,,,
1,3,SKILLFULLY SHOT,EARN OZ LANES SKILL SHOT 1 TIME,1,unlimited,TRUE,counter,FALSE,FALSE,achievement_images/Achievement___obscured.png,achievement_images/Achievement__WOZ_Blue_2_Star.png,game,,,,,,,
```

The importer will perform an overwrite based on associated keys. For example, if the above file is imported, and a new file is imported that changes groupid and achievementid values, existing achievements that match those values will be overwritten, and any unique new value combinations of groupid/achievementid will generate new achievements.

You must take care to not "orphan" achievements. For example, if you create a groupId/achievementId combination of 4/1, 4/2, 4/3 and 4/4, then in a subsequent import only include 4/1, 4/2, and 4/3, the achievement for 4/4 will still exist in the database. This is functionally ok, but they should be removed through the admin feature or builder tool.

Please submit all CSV files to Scorbit for importing until we complete the manufacturer builder tool for general release.



### Retrieving Initial Master Set of Achievements

For Scorbitrons requesting the master achievements, they can be retrieved:

<pre><code><strong>GET /api/achievement/by_machine/{machine_id}/?user_id={user_id}&#x26;leveled={true/false}&#x26;showall={true/false}
</strong></code></pre>

| Arg         | Description                                                                                                                                                 |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| machine\_id | Integer (required) Scorbit machine id for the machine requesting the achievement                                                                            |
| user\_id    | Integer (optional) include user\_achievement information with each achievement object                                                                       |
| leveled     | Boolean (optional, default false): Sorts API response by group and level within group                                                                       |
| showall     | Boolean (optional, default false, only relevant when user\_id is provided): Will show all achievements or only achieved achievements based on the user\_id. |

The master achievement object behind the /achievements endpoint  has a number of components, some are dynamically generated (such as key) and some are set by the author of the achievement (such as description). Not all fields mentioned in the Model Fields table above are provided in the API serializer response with a GET request for a machine\_id, though **any one of them can be added upon request** should you wish to use them in your game logic.\
\
Note that the argument used while requesting this list significantly impacts the results. If an user\_id is provided, user\_achievement information for each achievement is also included in the list results. This is because this information is used by the app to display information related to achievements at both a machine level and a user level.

The leveled=true and showall=true are used along with a user\_id, so the app can display different sorted lists and filtered lists depending on the request.

Here is a typical response:

```
{
  "count": 119,
  "total_count": 121,
  "total_achieved": 13,
  "achievements": [
    {
      "id": 271,
      "name": "100,000 PIC SPINS...",
      "key": "JJP-GNR-39-115",
      "description": "PLAYED SLASH SOLO 50 TIMES",
      "group_id": 87,
      "input_time": "unlimited",
      "obscure": true,
      "visible": true,
      "scope": "specific",
      "permanence": "permanent",
      "image": "https://scorbit-cdn.scorbit.io/achievement_images/Achievement__GNR_Blue_5_Star.png",
      "obscure_image_url": "https://scorbit-cdn.scorbit.io/achievement_images/Achievement___obscured.png",
      "count": 50,
      "level": 3,
      "frame": null,
      "frame_version": 0,
      "venue_id": null,
      "trigger": "game",
      "mode_name": null,
      "mode_name_2": null,
      "mode_name_3": null,
      "mode_type": null,
      "comparison": null,
      "target_score": null,
      "user_achievement": null
    },
    {
      "id": 187,
      "name": "1+1 = 3",
      "key": "JJP-GNR-10-31",
      "description": "COLLECTED 1 PATCH SET",
      "group_id": 58,
      "input_time": "unlimited",
      "obscure": false,
      "visible": true,
      "scope": "specific",
      "permanence": "permanent",
      "image": "https://scorbit-cdn.scorbit.io/achievement_images/Achievement__GNR_Blue_2_Star.png",
      "obscure_image_url": "https://scorbit-cdn.scorbit.io/achievement_images/Achievement___obscured.png",
      "count": 1,
      "level": 1,
      "frame": null,
      "frame_version": 0,
      "venue_id": null,
      "trigger": "game",
      "mode_name": null,
      "mode_name_2": null,
      "mode_name_3": null,
      "mode_type": null,
      "comparison": null,
      "target_score": null,
      "user_achievement": null
    },
    {
      "id": 244,
      "name": "2ND LEG OF THE TOUR",
      "key": "JJP-GNR-31-88",
      "description": "PLAYED ON THE ROAD TWO 1 TIME",
      "group_id": 79,
      "input_time": "unlimited",
      "obscure": false,
      "visible": true,
      "scope": "specific",
      "permanence": "permanent",
      "image": "https://scorbit-cdn.scorbit.io/achievement_images/Achievement__GNR_Blue_3_Star.png",
      "obscure_image_url": "https://scorbit-cdn.scorbit.io/achievement_images/Achievement___obscured.png",
      "count": 1,
      "level": 1,
      "frame": null,
      "frame_version": 0,
      "venue_id": null,
      "trigger": "game",
      "mode_name": null,
      "mode_name_2": null,
      "mode_name_3": null,
      "mode_type": null,
      "comparison": null,
      "target_score": null,
      "user_achievement": null
    },
    
[...]

    {
      "id": 161,
      "name": "YOU HONESTLY HAVE TO TRY TO SUCK THIS BAD",
      "key": "JJP-GNR-1-5",
      "description": "GOT BOOED OFF STAGE 25 TIMES",
      "group_id": 49,
      "input_time": "unlimited",
      "obscure": true,
      "visible": true,
      "scope": "specific",
      "permanence": "permanent",
      "image": "https://scorbit-cdn.scorbit.io/achievement_images/Achievement__GNR_Blue_1_Star.png",
      "obscure_image_url": "https://scorbit-cdn.scorbit.io/achievement_images/Achievement___obscured.png",
      "count": 25,
      "level": 3,
      "frame": null,
      "frame_version": 0,
      "venue_id": null,
      "trigger": "game",
      "mode_name": null,
      "mode_name_2": null,
      "mode_name_3": null,
      "mode_type": null,
      "comparison": null,
      "target_score": null,
      "user_achievement": {
        "id": 54585,
        "achieved": false,
        "count": 1
      }
    }
  ]
}
```

### Interacting with User Achievements

Once the game code or Scorbitron knows what to track, they will receive a user's position and userID in a /entry response. Once received, the Scorbitron should get a user or series of users current UserAchievement state from the /user\_achievement endpoint.

`GET /user_achievement/{machine_id}/?users={user_id_list}`

_-args: {machine\_id}, {user\_id\_list}_

|                | Description                                                              |
| -------------- | ------------------------------------------------------------------------ |
| machine\_id    | (required) Scorbit machine id for the machine requesting the achievement |
| user\_id\_list | (at least one required) list of user ids requested                       |

Machine groups (i.e. machines that have the same physics and game rules, but have different IDs) are not necessary, as they will share the same achievement keys.

**Example call for pulling achievement update**

```
curl -X GET "https://scorbit-api-staging.herokuapp.com/api/user_achievement/479?users=1,7,8,9,10,13" \
  --header "accept: application/json" \
  --header "Authorization: SToken kDYkjFCXOVCZvRq5DMiQxz8jdZ4jzj5HZ5NIdLGaqf7RXu5ZuxeTGe0kwl8cGCJC"
```

For single user:

```
curl -X GET "https://scorbit-api-staging.herokuapp.com/api/user_achievement/479?users=4" \
  --header "accept: application/json" \
  --header "Authorization: SToken kDYkjFCXOVCZvRq5DMiQxz8jdZ4jzj5HZ5NIdLGaqf7RXu5ZuxeTGe0kwl8cGCJC"
```

The response from the /user\_achievements endpoint will look as follows:

```
[
  {
    "user": {
      "id": 4,
      "cached_display_name": "Jay Adelson",
      "profile_picture": "https://scorbit-cdn.scorbit.io/profile_pictures/7e12e85a-8774-442e-8f3f-d6869da48980.jpg",
      "display_name": "Jay Adelson",
      "initials": "JSA",
      "username": "jay",
      "first_name": "Jay",
      "last_name": "Adelson"
    },
    "achievements": [
      {
        "id": 1125,
        "key": "JJP-WW-22-77",
        "count": 1,
        "achieved": true
      },
      {
        "id": 1126,
        "key": "JJP-WW-22-78",
        "count": 1,
        "achieved": false
      },
      {
        "id": 1127,
        "key": "JJP-WW-22-79",
        "count": 1,
        "achieved": false
      },
      {
        "id": 1128,
        "key": "JJP-WW-39-128",
        "count": 1,
        "achieved": true
      },
      {
        "id": 1129,
        "key": "JJP-WW-39-129",
        "count": 1,
        "achieved": false
      },
      {
        "id": 1130,
        "key": "JJP-WW-39-130",
        "count": 1,
        "achieved": false
      }
    ]
  }
]
```

#### Achievement Groups

Achievement objects are unique and assigned an achievement\_id. Additionally, every achievement also has a group\_id. It is sometimes desired to associate a group of achievements with each other, both for semantic reasons or related to game rules. Any achievement can be grouped with any other achievement.

If an achievement is of type _**count**_, the count will be an integer needed to achieve the achievement. If there are several achievements that are counting the same thing, and they also happen to be part of the same group, the API will assign those achievements **levels** based on the order of the counts. For example, an achievement with a count of 1 may be level 1, a count of 20 be level 2, and a count of 100 be level 3. These levels are dynamically generated based on the groupings and if they count the same thing.

#### Unlocking and Locking Achievements

When a user begins to earn an achievement, the venuemachine (client) needs to first _unlock_ the user\_achievement associated with that achievement's key.

One way to think about it is that **unlocking** is a process that takes time. The client is continuously sending updates to the API, like a key slowly turning in a lock.

One the user\_achievement exists through the unlock statement, the client should continue to unlock the same achievement with incrementing counts. Once the achievement crosses the target count threshold, achieved=true and responses will indicate such. It is also possible for the client to transition an achievement from achieved=false to achieved=true.

_Locking_ achievements is reserved for when **trophy** achievements are removed from one user and given to another. It effectively changes the original user's user\_achievement to achieved=false and a locked status, and unlocks the next user's user\_achievement with an achieved=true status.

`POST /achievement/unlock --data {achievements}`

_-args: achievements: {key, count}, user\_id_

|          | Description                                                       |
| -------- | ----------------------------------------------------------------- |
| key      | unique identifier of the achievement                              |
| count    | optional, integer representing the total number of times achieved |
| user\_id | A player's user id                                                |

**Example achievement POST data**

```
curl -s --header "Content-Type: application/json"  
  --header "Authorization: SToken [sToken]"
  --request POST   --data
'{
    "achievements":
    [
      {
        "key": "JJP-WOZ-0-0",
        "count": 1
      },
      {
        "key": "JJP-WOZ-0-1",
        "count": 1
      },
      {
        "key": "JJP-WOZ-0-2",
        "count": 1
      },
    ],
        "user_id": 876
}'    https://staging.scorbit.io/api/achievement/unlock
```

**`POST /achievement/lock/`**

_-args: key, user\_id_

|          | Description                          |
| -------- | ------------------------------------ |
| key      | unique identifier of the achievement |
| user\_id | A player's user id                   |

### Unlimited vs. Limited Counts

Any achievement that counts something across games is referred to as an **unlimited** achievement. This means that upon completion of one session, the count will pick up where the player left off on the next session.

A limited achievement's count resets to zero at the start of a session. This way, the achievement requires the task be completed **within a single session.**

### Updating Unlimited Achievements

Achievements are unlocked or locked by authenticated calls to the API. Unlocking is not always in a single action, it generally means the user\_achievement is created with an initial count, not necessarily achieved=true. If an achievement has a count, POSTs to the endpoint for the achievement will keep track of totals, and when the achievement count is achieved it will be unlocked. Achievements without a count are considered boolean, and a count of 1 essentially means that it is unlocked.

For unlimited counts, all achievement keys associated with a count that increases should always be updated with the new total, starting off from where the userachievment indicates from when it was downloaded to the game. For example, if there are three achievements that all count a mode such as Multiball (MB), one for 1 time, one for 100 times, and one for 1000 times that the mode was launched, upon the first instance of MB, your userachievement counts would look like this:

* Achievement 1: 1/1
* Achievement 2: 1/100
* Achievement 3: 1/1000

When the user\_achievement is updated, the response would indicate that Achievement 1 changes from "achieved=false" to "achieved=true." Next time the user hits MB, the counts would increase, even for previously achieved counts:

* Achievement 1: 2/1
* Achievement 2: 2/100
* Achievement 3: 2/1000

This process continues until the next achievement is achieved.

### Updating LImited Achievements

For limited counts, the counter always resets to zero at the start of a game. If the nature of an achievement benefits from showing the total the player has received for that game, even if not achieved, the game can update the count in real-time to show a progress indicator on the achievement object view on the app. However, it is also an option to only update the final count if the achievement is achieved. This is based on the game logic and frequency of updates.

### Locking and Trophy Achievements

Locking an achievement essentially is a more rare condition used for _**trophy achievements**_. When one user steals a trophy achievement from another user, these achievements are locked on the first user (but remain as a locked object in the UserAchievement list) and unlocked on the new user.

### The user\_achievement Model

The user\_achievement model refers to the achievement attached to a specific user. Fields include:

|             | Description                                         |
| ----------- | --------------------------------------------------- |
| id          | unique identifier of the user achievement           |
| achievement | id of the achievement                               |
| achieved    | boolean, if user has unlocked the achievement       |
| count       | integer, number of times the rule has been achieved |

The additional information associated with the master achievement is generally not relevant as the game logic is responsible for processing that information when downloaded from the achievement endpoint. This way, user\_achievements are kept simple, with an id,&#x20;
