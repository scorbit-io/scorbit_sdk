/*
 * Scorbit SDK
 *
 * (c) 2025 Spinner Systems, Inc. (DBA Scorbit), scrobit.io, All Rights Reserved
 *
 * MIT License
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#pragma once

#include <scorbit_sdk/net_types_c.h>
#include <openssl/sha.h>
#include <openssl/evp.h>
#include <openssl/ec.h>
#include <openssl/ecdsa.h>
#include <cstdint>
#include <memory>
#include <vector>
#include <array>

// To supresss OpenSSL 1.0.x API's deprecation warnings
#if defined(__GNUC__)
#    pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__clang__)
#    pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(_MSC_VER)
#    pragma warning(disable : 4996) // Disable deprecation warnings
#endif

namespace scorbit {
namespace detail {

enum class SignErrorCode {
    Ok = 0,
    OpenSSLInitFailure,
    CreateECKeyFailure,
    CreateBIGNUMFailure,
    SetPrivateKeyFailure,
    CreateECPointFailure,
    CalculatePublicKeyFailure,
    SetPublicKeyFailure,
    InvalidKey,
    KeyCannotSign,
    SignFailure,
    InvalidSignature
};


/**
 * @brief scorbit_sign used to sign given digest with the given private key.
 *
 * @param[out] signature - generated signature in DER format, it has to be pre-allocated buffer with
 *      at least SB_SIGNATURE_MAX_LENGTH (72) bytes.
 * @param[out] signature_len - actual length of the signature, not more than SB_SIGNATURE_MAX_LENGTH
 *      (72) bytes.
 * @param[in] digest - digest to sign (32 bytes), it's a SHA-256 hash, can be generated by
 *      @ref scorbit_digest.
 * @param[in] key - private key in binary format (32 bytes).
 *
 * @return error code or SIGN_OK if successful.
 */class Signer
{
public:
    static SignErrorCode sign(std::vector<uint8_t> &signature,
                              const std::array<uint8_t, SB_DIGEST_LENGTH> &digest,
                              const std::vector<uint8_t> &key)
    {
        EC_KEY_ptr ecKey(EC_KEY_new_by_curve_name(NID_X9_62_prime256v1), EC_KEY_free);
        if (!ecKey)
            return SignErrorCode::CreateECKeyFailure;

        BIGNUM_ptr privKeyBn(BN_bin2bn(key.data(), key.size(), nullptr), BN_free);
        if (!privKeyBn)
            return SignErrorCode::CreateBIGNUMFailure;

        if (EC_KEY_set_private_key(ecKey.get(), privKeyBn.get()) != 1)
            return SignErrorCode::SetPrivateKeyFailure;

        EC_POINT_ptr ecPoint(EC_POINT_new(EC_KEY_get0_group(ecKey.get())), EC_POINT_free);
        if (!ecPoint)
            return SignErrorCode::CreateECPointFailure;

        if (EC_POINT_mul(EC_KEY_get0_group(ecKey.get()), ecPoint.get(), privKeyBn.get(), nullptr,
                         nullptr, nullptr)
            != 1)
            return SignErrorCode::CalculatePublicKeyFailure;

        if (EC_KEY_set_public_key(ecKey.get(), ecPoint.get()) != 1)
            return SignErrorCode::SetPublicKeyFailure;

        if (EC_KEY_check_key(ecKey.get()) != 1)
            return SignErrorCode::InvalidKey;

        if (EC_KEY_can_sign(ecKey.get()) != 1)
            return SignErrorCode::KeyCannotSign;

        ECDSA_SIG_ptr sig(ECDSA_do_sign(digest.data(), digest.size(), ecKey.get()), ECDSA_SIG_free);
        if (!sig)
            return SignErrorCode::SignFailure;

        int len = i2d_ECDSA_SIG(sig.get(), nullptr);
        if (len <= 0)
            return SignErrorCode::InvalidSignature;

        signature.resize(len);
        uint8_t *sigData = signature.data();
        i2d_ECDSA_SIG(sig.get(), &sigData);

        return SignErrorCode::Ok;
    }

private:
    using EC_KEY_ptr = std::unique_ptr<EC_KEY, decltype(&EC_KEY_free)>;
    using BIGNUM_ptr = std::unique_ptr<BIGNUM, decltype(&BN_free)>;
    using EC_POINT_ptr = std::unique_ptr<EC_POINT, decltype(&EC_POINT_free)>;
    using ECDSA_SIG_ptr = std::unique_ptr<ECDSA_SIG, decltype(&ECDSA_SIG_free)>;
};

} // namespace detail
} // namespace scorbit
