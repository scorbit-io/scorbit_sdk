# Authentication

## Introduction

All machines that connect to Scorbit are unique and authenticated. When a user creates a virtual version of the machine on the Scorbit platform (referred to internally as a _**venuemachine**_), that venuemachine must be paired to an actual machine in the real world. When a new machine is powered up, it generates or retrieves (with its own code) a unique serial number based on a format unique to the manufacturer. That number is then used to communicate with the API with a unique UUID that is stored locally and the Scorbit API. When the machine connects to the Scorbit platform for the first time, _**a virtual version of that physical machine**_ is created, which we internally refer to as provisioning. The connection between the physical machine's UUID and the venuemachine (pairing) is made by the machine passing the UUID to the app during the user's initial installation (using a QR code or other means), and the app providing a way for the user to attach the venuemachine to that UUID.

## Outline of Connection Steps

1. [**UUID**](02.-authentication.md#generating-a-uuid): Machine generates a proper UUID used in pairing, initial connection and authentication.
2. [**Authenticate**](02.-authentication.md#authentication-philosophy): UUID is used to authenticate, using a token, a connected machine.
3. [**Configure**](configure.md): POST your version of your code to /api/installed endpoint
4. [**Heartbeat**](04.-heartbeat.md): Machine heartbeats online, regardless of Scorbit's pairing status.&#x20;
5. [**Session**](05.-api-usage.md): Machine heartbeats and uses entry endpoint to POST scores via websockets or new connections.

## Dictionary

* `byte` - unsigned char (uint8\_t)
* `provider` - string, value `manufacturer_name`
* `UUID` - is 16 bytes array (`{0xa2, 0x6a, 0x3b, 0xc2, 0x67, 0xaa, 0x47, 0xe1, 0xae, 0x84, 0x53, 0xaf, 0x4a, 0x33, 0x94, 0x1a}`), converted to hex format string to send to API (`"a26a3bc267aa47e1ae8453af4a33941a"`)
* `serial number` - Max 32 bit internally stored as unsigned integer number, converted to string number to send to API (`"15004"`).
* `timestamp` - current unix timestamp, converted to number string to send to API (`"1592834780"`)
* `<base_url>` - production: https://api.scorbit.io, staging: https://scorbit-api-staging.herokuapp.com
* `stoken` - Scorbitron token received by the machine network client following a secure authentication

***

## Authentication Philosophy

As explained, all Scorbit machine relationships require both a virtual representation of the machine's network client, known as a _**Scorbitron**_, and a virtual representation of the machine for the platform, known as a _**venuemachine**_.

Internal to Scorbit, the Scorbitrons are named for the manufacturer involved. For example, where a Scorbit Scorbitron is named with a simple id number, a manufacturer Scorbitron may be named for the manufacturer and id number, like `[Manufacturer] - [scorbitronId]`.

There may only be a single instance for any given Scorbitron's UUID on the platform. However, these UUID can be paired with various different venuemachines over time, but only one at a time. For example, if a pinball machine is sold to a new owner, they may create a new venuemachine in their app, but the Scorbitron pairing would move from old venuemachine to the new venuemachine.

We rely on the user and the app to create the venuemachines automatically through our user interfaces. However, a Scorbitron is automatically provisioned the first time it authenticates with the API. The process of initial authentication is critical, as it sets up the target ScorbitronId which is authenticated against going forward.

### Authentication Pre-Requisites

1. A private key generated and securely stored in TPM (or if no TPM is available, obfuscated and incorporated in executable binary). The corresponding public key is provided to Scorbit and stored in Scorbit API
2. The machine should always have its permanent UUID and serial number accessible locally. Note: The serial number of the connected device isn't always the serial number of the machine, depending on your architecture. However, you will want to store the serial and UUID permanently, as future UUID generation tools could change. A TPM is perfect for this, or a WiFi dongle that has a TPM feature, or a TPM USB dongle, though ideally an on-board TPM chip which is part of many motherboard configurations.
3. The machine must be already connected to WiFi via a manufacturer's instructions.
4. Prior to authenticating, the machine _**must have already updated its clock time**_ via some form of network time sync such as chrony or systemd-timesyncd. This is required for secure authorization and is a standard best-practice. The clock should have deviance of not more than 20 seconds to accommodate for general Internet latencies.

### A Note on Network Time

We realize that the UI considerations for setting clock time are considerable, but without it, we cannot guarantee security for a connected device. This is table stakes for entering the connected world. Note that the API expects a UNIX time stamp which is UTC time. If you display local time on your machine, you will need to accommodate the conversion to local time zone via your own settings and UI, which is best practice regardless.\
\
We have found that Linux-based systems that use the systemd/systemctl systems are already set up to operate this way. For example, for an Ubuntu system that is running Ubuntu 20 or higher, your process to get time working would be straightforward. Here are high level instructions, but please consult with package documentation as your mileage may vary:

First purge any references to ntpd or systemd-timesyncd, which are problematic:

```
$ sudo apt update
$ sudo apt purge ntpd
$ sudo systemctl disable systemd-timesyncd
```

Next add Chrony, the most modern package used for keeping time in sync:

```
$ sudo apt install chrony
```

Now you have to set your dependencies to ensure that time in synchronized prior to attempting to authenticate. These files can be found in /etc/systemd. The first is to ensure the file located in /etc/systemd/system/chronyd.service is configured to use a viable ntp pool. Here is an example:

```
$ sudo cat chronyd.service 
[Unit]
Description=chrony, an NTP client/server
Documentation=man:chronyd(8) man:chronyc(1) man:chrony.conf(5)
Conflicts=openntpd.service ntp.service ntpsec.service
Wants=time-sync.target
Before=time-sync.target
After=network.target

[Service]
Type=forking
PIDFile=/run/chrony/chronyd.pid
EnvironmentFile=-/etc/default/chrony
ExecStart=/usr/lib/systemd/scripts/chronyd-starter.sh $DAEMON_OPTS

CapabilityBoundingSet=~CAP_AUDIT_CONTROL CAP_AUDIT_READ CAP_AUDIT_WRITE
CapabilityBoundingSet=~CAP_BLOCK_SUSPEND CAP_KILL CAP_LEASE CAP_LINUX_IMMUTABLE
CapabilityBoundingSet=~CAP_MAC_ADMIN CAP_MAC_OVERRIDE CAP_MKNOD CAP_SYS_ADMIN
CapabilityBoundingSet=~CAP_SYS_BOOT CAP_SYS_CHROOT CAP_SYS_MODULE CAP_SYS_PACCT
CapabilityBoundingSet=~CAP_SYS_PTRACE CAP_SYS_RAWIO CAP_SYS_TTY_CONFIG CAP_WAKE_ALARM
DeviceAllow=char-pps rw
DeviceAllow=char-ptp rw
DeviceAllow=char-rtc rw
DevicePolicy=closed
LockPersonality=yes
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
PrivateTmp=yes
ProcSubset=pid
ProtectControlGroups=yes
ProtectHome=yes
#ProtectHostname=yes
ProtectKernelLogs=yes
ProtectKernelModules=yes
ProtectKernelTunables=yes
ProtectProc=invisible
ProtectSystem=strict
ReadWritePaths=/run /var/lib/chrony -/var/log
RestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX
RestrictNamespaces=yes
RestrictSUIDSGID=yes
SystemCallArchitectures=native
SystemCallFilter=~@cpu-emulation @debug @module @mount @obsolete @raw-io @reboot @swap

# Adjust restrictions for /usr/sbin/sendmail (mailonchange directive)
NoNewPrivileges=no
ReadWritePaths=-/var/spool
RestrictAddressFamilies=AF_NETLINK

[Install]
Alias=chronyd.service
WantedBy=multi-user.target
```

Any other services, such as game code, an API client or authentication code, that require time sync can have their .service files to look similar to this example, which waits for time before starting a connection client/agent type of service:

```
$ sudo cat [your_connection_client].service 
[Unit]
Description=[client_name]
Documentation=https://support.scorbit.io
After=[prerun.service, like wifi related] network-online.target nss-lookup.target
Wants=network-online.target nss-lookup.target time-sync.target

[Service]
Type=exec
User=root
Group=root
ExecStartPre=/bin/bash -c 'until host api.scorbit.io; do sleep 1; done'
ExecStartPre=/usr/bin/chronyc -h 127.0.0.1,::1 waitsync 0 0.1 0.0 1
ExecStart=[/path-to-service-you-want-to-start]
Restart=always
KillMode=process

TimeoutStopSec=60
WatchdogSec=15

[Install]
WantedBy=multi-user.target

```

Network time dependencies ideally should be soft. If there are Internet connectivity issues, you don't want to disable game play. A more flexible approach is to alert the user to the state of connectivity so if authentication is failing, they know why.

### Cache Bypass

It should be noted up front that all requests for provisioning and authentication must include proper cache bypass control in the header. Using curl, this is done by adding:

```
-H 'Cache-Control: no-cache'
```

to outbound curl requests along side other Authorization and Content-Type headers. For implementations other than curl, **set a ‘Cache-Control’ header with a value of ‘no-cache’**.

### Generating a UUID

The machine UUID is a 16-byte hex string. We recommend starting with a manufacturer serial number, which should be limited to 32 bits (max number 2147483647). There are various methods of modifying or creating unique serial numbers to fit within these constraints. In the event that the machine does not incorporate a TPM with a permanent serial number, something like a MAC address could be used as the source to generate this number.

For example, a common command line tool to generate a UUID is `uuidgen`, which can be used with the following syntax where `$snum` is a `uint` of the machine's serial:

```
uuidgen --sha1 --namespace=\@oid --name=$snum
```

## Authentication Flow

Authentication with Scorbit always uses a nonce/token authentication scheme. The flow for any connection works as follows:

### Flow Steps

1. Generate a nonce by putting the 16-byte UUID in a buffer, followed by a textual, decimal representation of the timestamp (characters ‘0’ to ‘9’ which correspond to bytes 0x30 to 0x39). The nonce does not include a null terminator to that string.
2. Using the nonce, the machine must call an encryption function (see EncryptAuthenticationData() in section 03. ECDSA Signature as an example), _**encrypting this data with its private key, having previously provided the public key to Scorbit**_. Using this crypto library sign this `message` with the following parameters:

* ECDSA algorithm
* `sha-256` digest
* `secp256r1` curve (aka `prime256v1` aka `P-256`)

A signature can be 70-72 bytes in DER format or 64 bytes in raw format. _**Note that it is necessary to remove the leading 0x04 byte and only send the remaining 64 bytes.**_ Convert the `signature` to a hex string, for example:

```
"c9ee725c00638e05c10be3cb8a478b384fb2cb08673fcb5a584cc74ba4ed66785b05bc7181a343f875631150c0fd76666da4b3302e85752c89087a33cb831dc6"
```

to prepare it for sending to the API. For more information refer to [03. ECDSA Signature](03.-ecdsa-signature.md) page. The machine then uses a POST to send the encrypted data to the API (it must not send the nonce or UUID, but only encrypted result of the function.

The following Python script can be used to test and verify the signing is accurate:

#### Key Signing Verification Example

{% tabs %}
{% tab title="Python" %}
```python
from ecdsa import SigningKey, VerifyingKey, NIST256p, BadSignatureError
from ecdsa.util import sigdecode_der, sigdecode_string
import hashlib
import requests
import datetime
​
# Setup custom values
uuid = 'adc12b19a3504453a7414e722f58736b'
public_key = bytes.fromhex('36bf2f116d2dc477af294d7f2f95850d8d76df854d895fbcb0ad5fa186795b58eb5f9f82d72b0b52795b7cfd47f93d80e4d279aebda9efa4b2c61940b44de698')
provider = 'vscorbitron'
serial = 999990104
​
# Output values from signing application (in this case it's output from auth script)
signature_bytes = bytes.fromhex('5794358fe0e5b0e9113e023c60ac111b8e5427f3d38b3b140b9939472c0b02a9dd322ad5d29e918baffb09978fdb3c0831e5e0b5d53654d6883b6135882e4ce9')
timestamp_str = '1646330761'
​
# Recreate the signed message and verify the signature with the public key.
message = bytes.fromhex(uuid) + bytes(timestamp_str, 'utf-8')
vk = VerifyingKey.from_string(public_key, curve=NIST256p, hashfunc=hashlib.sha256)
sigdecode_fn = sigdecode_string if len(signature_bytes) == 64 else sigdecode_der
​
try:
    vk.verify(signature_bytes, message, sigdecode=sigdecode_fn)
    print("Verified OK")
except BadSignatureError as e:
    print(e)
```
{% endtab %}
{% endtabs %}

1. POST to the API to receive a stoken:

**`POST <base_url>/api/stoken/`**

{% swagger src=".gitbook/assets/swagger-config.json" path="/api/stoken/" method="post" %}
[swagger-config.json](.gitbook/assets/swagger-config.json)
{% endswagger %}

In this POST, given a UUID as a 16-byte array and timestamp (1592834780) converted to string ("1592834780" == {0x31, 0x35, 0x39, 0x32, 0x38, 0x33, 0x34, 0x37, 0x38, 0x30}), concatenate this two arrays into `message` array:

```
{
   0xa2, 0x6a, 0x3b, 0xc2, 0x67, 0xaa, 0x47, 0xe1, 0xae, 0x84, 0x53, 0xaf, 0x4a, 0x33, 0x94, 0x1a, // raw UUID
   0x31, 0x35, 0x39, 0x32, 0x38, 0x33, 0x34, 0x37, 0x38, 0x30 // timestamp converted to string
}
```

Use 5 parameters:

* `provider`
* `uuid`
* `serial_number`
* `machine_id [optional]`
* `timestamp`
* `sign` in x-www-form-urlencoded format:

```
provider=manufacturer_name&uuid=a26a3bc267aa47e1ae8453af4a33941a&serial_number=15004&machine_id=[machine_id]&timestamp=1592834780&sign=c9ee725c00638e05c10be3cb8a478b384fb2cb08673fcb5a584cc74ba4ed66785b05bc7181a343f875631150c0fd76666da4b3302e85752c89087a33cb831dc6
```

### Authentication Python Code Example

The following Python code can be used as an example to retrieve a stoken from the Scorbit API. Note that the private key used in this example is a Scorbitron used for test purposes only. To execute this script, you must first execute:

```bash
pip install ecdsa requests
```

to install the required ECDSA libraries.

<pre class="language-python"><code class="lang-python">from ecdsa import SigningKey, VerifyingKey, NIST256p, BadSignatureError
from ecdsa.util import sigdecode_der, sigdecode_string
import hashlib
import requests
import datetime

# Setup custom values. These will function for tests but all values should be replaced to test provisioning.
# Note that the machine_id field is optional, but recommended, so that unpaired Scorbitrons
# can be identified properly.
<strong>uuid = 'adc12b19a3504453a7414e722f58736b'
</strong>private_key = bytes.fromhex('bfeac1a0c5679029c980bdeae9260385723e6ba9edde6f831c63ac75ee74ed38')
provider = 'vscorbitron'
serial = 999990104
machine_id = 3774

domain = 'staging.scorbit.io'
stoken_url = 'https://' + domain + '/api/stoken/'

# Prepare signature
sk = SigningKey.from_string(private_key, curve=NIST256p, hashfunc=hashlib.sha256)

# Recreate public key from private key and print it.
# It must match to the public key stored in the API
public_key = sk.verifying_key.to_string()
print('Public key: ' + public_key.hex())

# Get current timestamp in seconds (convert to int) and convert it to string
timestamp_str = str(int(datetime.datetime.now().timestamp()))
nonce = bytes.fromhex(uuid) + bytes(timestamp_str, 'utf-8')

print('Timestamp: ' + timestamp_str)

# print the nonce we are going to sign
print('Nonce to be signed: ' + nonce.hex())

# Sign nonce which is bytearray
signature_bytes = sk.sign(nonce)

# Post request
payload = {
    'provider': provider,
    'uuid': uuid,
    'serial_number': serial,
    'machine_id' : machine_id,
    'timestamp': timestamp_str,
    'sign': signature_bytes.hex()
}

print(payload)

r = requests.post(stoken_url, headers = {"Cache-Control": "no-cache"}, data = payload)
print(r.json())
</code></pre>

### API Response

If the auth string decrypts and matches the nonce properly:

```json
{
    "stoken": "<auth_token>"
}
```

For example:

```json
{
    "stoken": "abcd00119283911f"
}
```

Errors:

If no nonce exists on the session (probably because /api/nonce was not called first):

```json
{
    "error": "No Session Nonce Found",
    "error_code": "nonce_not_found"
}
```

If the nonce was already used:

```json
{
    "error": "Nonce has already been redeemed",
    "error_code": "nonce_expired"
}
```

If the nonce in the session does not match the nonce encrypted in the payload:

```json
{
    "error": "Nonce does not match session",
    "error_code": "nonce_mismatch"
}
```

### Using the Token

This token will be used for further API communication as `Authorization: SToken abcd00119283911f` header. More information can be found in the [API Usage / Entry](05.-api-usage.md) section.

### UUID Management

The UUID created in the provisioning is now permanently associated with this machine. In the case that it is lost, it has to be manually regenerated using the source information locally. The authentication process would be repeated to get to acquire a stoken.

When a machine later heartbeats (see [Heartbeat](04.-heartbeat.md)), based on the responses explained in the next sections, it knows if it has already been paired with a venuemachine and passes back the venuemachineID.

## Using a QR Code for Automated Pairing

As mentioned in the Introduction, Scorbit pairs a _Scorbitron_ object with a _venuemachine_ object when a user connects a machine to the platform. To do this, the user creates a venuemachine using the app or online tools and then enters the menu for that machine. Within the menu, there is a Tools section that allows the user to "activate Scorbit," which takes them through a series of instructions on what to do on the manufacturer's machine to activate.

Recognizing that this flow:

**Download App > Create Venuemachine and Venue > Edit Machine > Open Tools > Activate Scorbit**

...may be confusing and burdensome for users, we have provided an easy way to simplify the process using a QR code.

### Deeplinking Pairing with a QR Code

When an iOS or Android device scans a QR code that uses the Scorbit syntax, and an app isn't already installed, the user is taken to the appropriate app store and the app is downloaded first.

Once the app exists, the app will automatically open to the appropriate screen, or wizard, to simplify the pairing process. For a machine that is _**not yet connected to Scorbit**_, The QR code should be a URL following syntax:

`https://scorbit.link/qrcode?$deeplink_path=[manufacturer_prefix]&machineid=[scorbit_machine_id]&uuid=[scorbitron_uuid]`

For example:

`https://scorbit.link/qrcode?$deeplink_path=jjp&machineid=1861&uuid=c608c31d-92d1-5262-9c8b-e8f562debb50`

Where the parameters translate to:

| Parameter            | Description                                                                                                        |
| -------------------- | ------------------------------------------------------------------------------------------------------------------ |
| deeplink\_path       | This represents the internal URL used by the OS and the app to determine the app behavior upon scanning.           |
| manufacturer\_prefix | This is a short version of a manufacturer named assigned by Scorbit to the manufacturer to simplify the URL.       |
| scorbit\_machine\_id | Scorbit uses a unique ID for every machine title. This is not the same as an OPDB id.                              |
| scorbitron\_uuid     | This is the UUID retrieved in the above provisioning process. This should exist after a game is connected to WiFi. |

When the app scans this QR code embedded with the unique UUID, a window will open in the app offering the user choices on creating a new venuemachine, pairing an existing venuemachine, or skipping the wizard entirely.

### Game Menu Considerations

It is generally good practice to reveal if a machine is already paired with Scorbit on the game, and if a user wishes to detach or re-pair the game, provide them an option to do so locally. This doesn't mean the machine forgets the UUID, it just means that the "connected" state needs to be maintained locally based on the authentication response at startup, and that this state is intentionally ignored allowing the user to proceed with pairing as a new or existing venuemachine. Scorbit will automatically handle this move on the backend.

The goal is for the game to be relatively insensitive to what state it was in when it passes from owner to owner, or is moved.

When Scorbit "detaches" the venuemachine from the Scorbitron, heartbeats will present an appropriate error (see the section [04. Heartbeat](04.-Heartbeat) for more information). At that point, the game menu should return to a disconnected state.

### Deeplinking Navigation and Claiming Slots with a QR Code

If you use QR codes in your game's display to navigate to the game session in the app, it is important to distinguish between these codes!

The QR code in the game settings menu used for PAIRING should change to a NAVIGATION/CLAIMING aid syntax when the game is in a connected state:

`https://scorbit.link/qrcode?$deeplink_path=[venuemachineID]&opdb=[opdbID]&position=[player number]`

For example:

`https://scorbit.link/qrcode?$deeplink_path=22332&opdb=GRD79-M0odk&position=1`

Where the parameters translate to:

| Parameter      | Description                                                                                              |
| -------------- | -------------------------------------------------------------------------------------------------------- |
| deeplink\_path | This represents the internal URL used by the OS and the app to determine the app behavior upon scanning. |
| venuemachineID | This is the paired venuemachineID and is presented in authentication and heartbeat responses.            |
| opdbID         | This is the unique identifier in the [Open Pinball Database](https://opdb.org/)                          |
| position       | OPTIONAL, Integer representing the player number.                                                        |



We recommend changing the Scorbit connect menu to present this QR code when the game is paired to avoid confusion, along with an option to detach the game and return the QR code to a unpaired state.
